let score = 0;

// Create a Phaser game configuration
const config = {
    type: Phaser.AUTO,
    width: 1280,
    height: 720,
    parent: 'body',
    physics: {
        default: 'arcade',
        arcade: {
            debug: false // Set this to true to enable physics debug information
        }
    },
    scene: {
        preload: preload,
        create: create,
        update: update
    }
};

// Create a new Phaser game
const game = new Phaser.Game(config);

// Variables for the knight sprites and movement
let goodKnight;
let badKnight;
let followerKnights = [];
let cursors;
let spacebar;
let isRunning = false;
let scoreText;

// Preload function
function preload() {
    console.log('Preload');
    // Load sprite images
    this.load.spritesheet('knight', 'assets/knight.png', { frameWidth: 16, frameHeight: 32 });
}

// Create function
function create() {
    console.log('Create');

    // Create a text object to display the score
    scoreText = this.add.text(config.width - 10, 10, 'Score: 00000', {
        fontFamily: 'Arial',
        fontSize: 20,
        color: '#ffffff',
        align: 'right'
    });
    scoreText.setOrigin(1, 0); // Set the origin to the top-right corner

    // Create the goodKnight sprite
    const randomX = Phaser.Math.Between(0, config.width);
    const randomY = Phaser.Math.Between(0, config.height);
    goodKnight = this.physics.add.sprite(randomX, randomY, 'knight', 0);
    goodKnight.setScale(2.5);

    // Create the badKnight sprite
    const badRandomX = Phaser.Math.Between(0, config.width);
    const badRandomY = Phaser.Math.Between(0, config.height);
    badKnight = this.physics.add.sprite(badRandomX, badRandomY, 'knight', 0);
    badKnight.setScale(2.5);
    badKnight.setTint(0xff0000); // Set the tint to red

    // Set up animations for goodKnight (same as before)
    this.anims.create({
        key: 'walkDown',
        frames: this.anims.generateFrameNumbers('knight', { start: 0, end: 2, first: 0 }),
        frameRate: 8,
        repeat: -1
    });

    this.anims.create({
        key: 'walkUp',
        frames: this.anims.generateFrameNumbers('knight', { start: 3, end: 5, first: 3 }),
        frameRate: 8,
        repeat: -1
    });

    this.anims.create({
        key: 'walkLeft',
        frames: this.anims.generateFrameNumbers('knight', { start: 6, end: 8, first: 6 }),
        frameRate: 8,
        repeat: -1
    });

    this.anims.create({
        key: 'runDown',
        frames: this.anims.generateFrameNumbers('knight', { start: 9, end: 11, first: 9 }),
        frameRate: 12,
        repeat: -1
    });

    this.anims.create({
        key: 'runUp',
        frames: this.anims.generateFrameNumbers('knight', { start: 12, end: 14, first: 12 }),
        frameRate: 12,
        repeat: -1
    });

    this.anims.create({
        key: 'runLeft',
        frames: this.anims.generateFrameNumbers('knight', { start: 14, end: 16, first: 14 }),
        frameRate: 12,
        repeat: -1
    });

    // Set up keyboard input
    cursors = this.input.keyboard.addKeys({
        up: Phaser.Input.Keyboard.KeyCodes.W,
        down: Phaser.Input.Keyboard.KeyCodes.S,
        left: Phaser.Input.Keyboard.KeyCodes.A,
        right: Phaser.Input.Keyboard.KeyCodes.D,
    });
    spacebar = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.SPACE);

    this.input.keyboard.on('keydown-SPACE', () => {
        isRunning = !isRunning;
    });
}

function update() {

    // Check if goodKnight collides with the edge
    if (goodKnight.x < 0 || goodKnight.x > config.width || goodKnight.y < 0 || goodKnight.y > config.height) {
        // Reset the score to 0
        score = 0;

        // Remove children and empty follower array
        this.children.removeAll();
        followerKnights = [];

        // Restart the game
        this.scene.restart();
    }

    // Update the score text
    scoreText.setText(`Score: ${String(score).padStart(5, '0')}`);


    // Update knight movement based on input
    const speed = isRunning ? 200 : 100;
    let velocityX = 0;
    let velocityY = 0;

    // Store the previous velocity values
    let prevVelocityX = goodKnight.body.velocity.x;
    let prevVelocityY = goodKnight.body.velocity.y;


    // Check for different directional inputs
    if (cursors.up.isDown && cursors.down.isUp && cursors.left.isUp && cursors.right.isUp) {
        velocityY = -speed;
        velocityX = 0;
    } else if (cursors.down.isDown && cursors.up.isUp && cursors.left.isUp && cursors.right.isUp) {
        velocityY = speed;
        velocityX = 0;
    } else if (cursors.left.isDown && cursors.right.isUp && cursors.up.isUp && cursors.down.isUp) {
        velocityX = -speed;
        velocityY = 0;
    } else if (cursors.right.isDown && cursors.left.isUp && cursors.up.isUp && cursors.down.isUp) {
        velocityX = speed;
        velocityY = 0;
    } else if (cursors.up.isDown && cursors.left.isDown && cursors.right.isUp && cursors.down.isUp) {
        velocityY = -speed;
        velocityX = -speed;
    } else if (cursors.up.isDown && cursors.right.isDown && cursors.left.isUp && cursors.down.isUp) {
        velocityY = -speed;
        velocityX = speed;
    } else if (cursors.down.isDown && cursors.left.isDown && cursors.right.isUp && cursors.up.isUp) {
        velocityY = speed;
        velocityX = -speed;
    } else if (cursors.down.isDown && cursors.right.isDown && cursors.left.isUp && cursors.up.isUp) {
        velocityY = speed;
        velocityX = speed;
    } else {
        velocityX = prevVelocityX; // Continue with previous velocity if no change
        velocityY = prevVelocityY; // Continue with previous velocity if no change
    }

    goodKnight.body.velocity.x = velocityX;
    goodKnight.body.velocity.y = velocityY;

    // Normalize the direction of goodKnight
    const currentDirectionX = goodKnight.body.velocity.x;
    const currentDirectionY = goodKnight.body.velocity.y;
    const currentDistance = Math.sqrt(currentDirectionX * currentDirectionX + currentDirectionY * currentDirectionY);
    let normalizedDirectionX = 0;
    let normalizedDirectionY = 0;

    if (currentDistance !== 0) {
        normalizedDirectionX = currentDirectionX / currentDistance;
        normalizedDirectionY = currentDirectionY / currentDistance;
    }

    // Determine the absolute values of normalized direction for goodKnight
    const absNormalizedDirectionX = Math.abs(normalizedDirectionX);
    const absNormalizedDirectionY = Math.abs(normalizedDirectionY);

    // Update animation based on the direction of movement
    if (absNormalizedDirectionX > absNormalizedDirectionY) {
        if (normalizedDirectionX > 0) {
            goodKnight.anims.play('walkLeft', true);
            goodKnight.setFlipX(true); // Reset horizontal flip
        } else if (normalizedDirectionX < 0) {
            goodKnight.anims.play('walkLeft', true);
            goodKnight.setFlipX(false); // Flip horizontally
        }
    } else {
        if (normalizedDirectionY > 0) {
            goodKnight.anims.play('walkDown', true);
        } else if (normalizedDirectionY < 0) {
            goodKnight.anims.play('walkUp', true);
        }
    }

    // If there is no movement, stop the animation
    if (currentDistance === 0) {
        goodKnight.anims.stop();
    }


    // Update the positions and movement of followerKnights
    if (followerKnights.length > 0) {
        let prevFollower = goodKnight; // Starting point for the first follower

        for (let i = 0; i < followerKnights.length; i++) {
            const currentFollower = followerKnights[i];

            // Calculate the direction from the current follower to the previous follower
            const directionX = prevFollower.x - currentFollower.x;
            const directionY = prevFollower.y - currentFollower.y;

            // Normalize the direction and calculate the desired distance based on sprite size and scale
            const distance = Phaser.Math.Distance.Between(prevFollower.x, prevFollower.y, currentFollower.x, currentFollower.y);
            const desiredDistance = (prevFollower.width * prevFollower.scaleX * 0.8) + (currentFollower.width * currentFollower.scaleX * 0.8);

            // Adjust the velocity based on the difference between the desired distance and the current distance
            const normalizedDirectionX = directionX / distance;
            const normalizedDirectionY = directionY / distance;
            const followerSpeed = speed * 0.9; // Adjust the speed of the followerKnights (e.g., 0.9 for slightly slower speed)

            // Set the velocity of the current follower
            currentFollower.body.velocity.x = normalizedDirectionX * followerSpeed;
            currentFollower.body.velocity.y = normalizedDirectionY * followerSpeed;

            // Adjust the depth to maintain the order of sprites
            currentFollower.depth = goodKnight.depth - i - 1;

            // Calculate the new position to maintain the desired distance
            const newX = prevFollower.x - (normalizedDirectionX * desiredDistance);
            const newY = prevFollower.y - (normalizedDirectionY * desiredDistance);

            // Set the new position for the current follower
            currentFollower.x = newX;
            currentFollower.y = newY;

            // Determine the absolute values of normalizedDirectionX and normalizedDirectionY
            const absNormalizedDirectionX = Math.abs(normalizedDirectionX);
            const absNormalizedDirectionY = Math.abs(normalizedDirectionY);

            // Update animation based on the direction of movement
            if (absNormalizedDirectionX > absNormalizedDirectionY) {
                if (normalizedDirectionX > 0) {
                    currentFollower.anims.play('walkLeft', true);
                    currentFollower.setFlipX(true); // Reset horizontal flip
                } else if (normalizedDirectionX < 0) {
                    currentFollower.anims.play('walkLeft', true);
                    currentFollower.setFlipX(false); // Flip horizontally
                }
            } else {
                if (normalizedDirectionY > 0) {
                    currentFollower.anims.play('walkDown', true);
                } else if (normalizedDirectionY < 0) {
                    currentFollower.anims.play('walkUp', true);
                }
            }

            // If there is no movement, stop the animation
            if (normalizedDirectionX === 0 && normalizedDirectionY === 0) {
                currentFollower.anims.stop();
            }

            // Update the previous follower for the next iteration
            prevFollower = currentFollower;
        }
    }





    // Handle collision between goodKnight and badKnight
    this.physics.collide(goodKnight, badKnight, handleCollision, null, this);


}






// Function to handle collision between goodKnight and badKnight
function handleCollision() {
    // Remove the badKnight from the physics simulation
    badKnight.destroy();

    // Increase the score by 5
    score += 5;

    // Calculate the safe range for random positions
    const safeXRange = config.width - (badKnight.width * badKnight.scaleX);
    const safeYRange = config.height - (badKnight.height * badKnight.scaleY);

    // Generate random position for the new badKnight
    const randomX = Phaser.Math.Between(0, safeXRange);
    const randomY = Phaser.Math.Between(0, safeYRange);

    // Create a new badKnight at the random position
    badKnight = this.physics.add.sprite(randomX, randomY, 'knight', 0);
    badKnight.setScale(2.5);
    badKnight.setTint(0xff0000); // Set the tint to red

    // Create a followerKnight behind the previous followerKnight (if exists)
    let followerX;
    let followerY;
    if (followerKnights.length > 0) {
        let prevFollower = followerKnights[followerKnights.length - 1];
        followerX = prevFollower.x - (prevFollower.width * prevFollower.scaleX);
        followerY = prevFollower.y;
    } else {
        followerX = goodKnight.x - (goodKnight.width * goodKnight.scaleX);
        followerY = goodKnight.y;
    }

    // Create a followerKnight at the calculated position
    const followerKnight = this.physics.add.sprite(followerX, followerY, 'knight', 0);
    followerKnight.setScale(2.5);
    followerKnight.setTint(0x00ff00); // Set the tint to green

    // Update the reference to the most recent followerKnight
    followerKnights.push(followerKnight);
}







// Start the game
game.scene.start();
